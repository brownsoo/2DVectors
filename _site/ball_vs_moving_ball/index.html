<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>10) 공 vs 움직이는 공</title>
  <meta name="description" content="움직이는 공에 충돌하기 (Collision with moving ball)">

  <meta property="og:url"           content="http://localhost:4000/2DVectors/ball_vs_moving_ball/" />
  <meta property="og:type"          content="website" />
  <meta property="og:title"         content="10) 공 vs 움직이는 공" />
  <meta property="og:description"   content="움직이는 공에 충돌하기 (Collision with moving ball)" />
  <meta property="og:image"         content="http://localhost:4000/2DVectors/img/tut10_2.gif" />

  <link rel="stylesheet" href="/2DVectors/css/main.css">
  <link rel="canonical" href="http://localhost:4000/2DVectors/ball_vs_moving_ball/">
  <link rel="alternate" type="application/rss+xml" title="2D 벡터 알고리즘 기초" href="http://localhost:4000/2DVectors/feed.xml" />

  <script src="/2DVectors/js/processing-v1_6_6.js"></script>

</head>


  <body>

    
<!-- Load Facebook SDK for JavaScript -->
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&version=v2.5&appId=426537534208003";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>


<header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/2DVectors/">2D 벡터 알고리즘 기초</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/2DVectors/about/">About</a>
          
        
          
        
          
        
          
        

        <div class="top-nav">
        <ul>
    
    
    <li class="section">Basics</li>
    <li>
        <a href="/2DVectors/point_vector/">1) 포인트, 벡터</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/length_normals/">2) 길이, 노멀</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/adding_projecting/">3) 더하고, 투영하기</a>
    </li>
    
</ul>
<ul>
    
    
    <li class="section">Using vectors</li>
    <li>
        <a href="/2DVectors/move_accelerate/">4) 이동, 가속</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/intersection/">5) 교차</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/bounce/">6) 반동</a>
    </li>
    
</ul>
<ul>
    
    
    <li class="section">The ball</li>
    <li>
        <a href="/2DVectors/ball_vs_line/">7) 공 vs 선</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/ball_in_the_corner/">8) 코너에 있는 공</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/ball_vs_ball/">9) 공 vs 공</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/ball_vs_moving_ball/">10) 공 vs 움직이는 공</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/moving_balls/">11) 움직이는 공들</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/ball_vs_arc/">12) 공 vs 호</a>
    </li>
    
</ul>

<ul>
    
    
    <li class="section">Extras</li>
    <li>
        <a href="/2DVectors/download/">다운로드</a>
    </li>
    
</ul>


<div id="cc">
<!-- 저작권 -->
<a rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/deed.ko"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/2.0/88x31.png" /></a><br>
<br>
이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/deed.ko">크리에이티브 커먼즈 저작자표시-비영리 2.0 일반 라이선스</a>에 따라 이용할 수 있습니다.
</div>


<!-- Facebook like button code -->
<!-- <div class="fb-like" 
    data-href="http://localhost:4000/2DVectors" 
    data-layout="button_count"
    data-action="like" 
    data-share="true"
    data-width="300"
    data-show-faces="false">
</div> -->


<div id="browser">
본 사이트는 <b>HTML5</b> 를 지원하는 브라우저를 권장합니다.
</div>
<br>
<!-- 
<div class="alert">
현재 모바일에서는 예제의 인터랙션이 어렵습니다. 이 문제는 추후 보완될 가능성이 있습니다.^^
</div>
 -->

        </div>

      </div>
    </nav>

  </div>

</header>


    <div class="page-content">

      <div class="wrapper">

        <div class="side-nav">
          <ul>
    
    
    <li class="section">Basics</li>
    <li>
        <a href="/2DVectors/point_vector/">1) 포인트, 벡터</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/length_normals/">2) 길이, 노멀</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/adding_projecting/">3) 더하고, 투영하기</a>
    </li>
    
</ul>
<ul>
    
    
    <li class="section">Using vectors</li>
    <li>
        <a href="/2DVectors/move_accelerate/">4) 이동, 가속</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/intersection/">5) 교차</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/bounce/">6) 반동</a>
    </li>
    
</ul>
<ul>
    
    
    <li class="section">The ball</li>
    <li>
        <a href="/2DVectors/ball_vs_line/">7) 공 vs 선</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/ball_in_the_corner/">8) 코너에 있는 공</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/ball_vs_ball/">9) 공 vs 공</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/ball_vs_moving_ball/">10) 공 vs 움직이는 공</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/moving_balls/">11) 움직이는 공들</a>
    </li>
    
    
    <li>
        <a href="/2DVectors/ball_vs_arc/">12) 공 vs 호</a>
    </li>
    
</ul>

<ul>
    
    
    <li class="section">Extras</li>
    <li>
        <a href="/2DVectors/download/">다운로드</a>
    </li>
    
</ul>


<div id="cc">
<!-- 저작권 -->
<a rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/deed.ko"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/2.0/88x31.png" /></a><br>
<br>
이 저작물은 <a rel="license" href="http://creativecommons.org/licenses/by-nc/2.0/deed.ko">크리에이티브 커먼즈 저작자표시-비영리 2.0 일반 라이선스</a>에 따라 이용할 수 있습니다.
</div>


<!-- Facebook like button code -->
<!-- <div class="fb-like" 
    data-href="http://localhost:4000/2DVectors" 
    data-layout="button_count"
    data-action="like" 
    data-share="true"
    data-width="300"
    data-show-faces="false">
</div> -->


<div id="browser">
본 사이트는 <b>HTML5</b> 를 지원하는 브라우저를 권장합니다.
</div>
<br>
<!-- 
<div class="alert">
현재 모바일에서는 예제의 인터랙션이 어렵습니다. 이 문제는 추후 보완될 가능성이 있습니다.^^
</div>
 -->

        </div>

        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Ball vs Moving Ball</h1>
  </header>

  <article class="post-content">
    <h1 id="움직이는-공에-충돌하기-collision-with-moving-ball">움직이는 공에 충돌하기 (Collision with moving ball)</h1>

<p>지난 단계에서 2개 공의 충돌을 어떻게 확인하는지, 공의 반동 이후 움직임을 위한 새로운 방향을 찾는 법을 보았습니다. 
이것으로도 훌륭한 작업이지만, 문제가 좀 있습니다. 공이 매우 빠르게 움직일 수 없다는 것입니다. 그렇지 않으면 충돌검사가 실패합니다. 여기 그런 상황을 묘사한 것이 있습니다.</p>

<p><img src="../img/tut10_1.gif" alt="Alt 공의 충돌이 실패할 경우" /></p>

<p>그림에서 공1(빨강)은 위치 p0에 있고 속도 v로 움직이고 있습니다. 다음 렌더링 사이클에 공은 위치 p1(초록)에 있을 것입니다. 
이전 사이클에서 공2에 대한 충돌을 검사하였고 다음 움직임 이후 다시 충돌을 검사합니다. 시작 위치와 마지막 위치에서 둘다 공1은 공2로부터 너무 멀리 떨어져 있기 때문에, 공2에 대한 충돌을 검출해낼 수 없습니다. 실제로 공2에 충돌이 일어날 것은 분명한데도 말입니다.</p>

<p><img src="../img/tut10_2.gif" alt="Alt 움직이는 공의 충돌" /></p>

<p>그림에서 공1은 공2의 충돌은 위치 p3에서 일어납니다. 우리는 위치 p3를 몇개의 벡터를 이용해 계산할 수 있습니다.</p>

<p>먼저 움직임 이전에 두 공의 중심 사이 벡터를 구합니다 :</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">vc</span><span class="o">.</span><span class="na">p0</span> <span class="o">=</span> <span class="n">ball1</span><span class="o">.</span><span class="na">p0</span><span class="o">;</span>
<span class="n">vc</span><span class="o">.</span><span class="na">p1</span> <span class="o">=</span> <span class="n">ball2</span><span class="o">.</span><span class="na">p0</span><span class="o">;</span></code></pre></figure>

<p>이제 공 2와 운동 벡터에서 가장 가까운 점인 p2를 구합니다. 이 점은 벡터 vc 를 운동 벡터 v에 투영해서 쉽게 구할 수 있습니다. 점 p2에서 공 2의 중심으로 벡터를 그릴 수 있으며(vn), 이 벡터는 운동벡터 v의 노말과 같은 방향입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">  
<span class="c1">//projection of vc on movement vector</span>
<span class="n">Vector</span> <span class="n">vp</span> <span class="o">=</span> <span class="n">projectVector</span><span class="o">(</span><span class="n">vc</span><span class="o">,</span> <span class="n">ball1</span><span class="o">.</span><span class="na">dx</span><span class="o">,</span> <span class="n">ball1</span><span class="o">.</span><span class="na">dy</span><span class="o">);</span>
<span class="c1">//vector to center of ball2 in direction of movement vector's normal</span>
<span class="n">vn</span><span class="o">.</span><span class="na">p0</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">(</span><span class="n">ball1</span><span class="o">.</span><span class="na">p0</span><span class="o">.</span><span class="na">x</span><span class="o">+</span><span class="n">vp</span><span class="o">.</span><span class="na">vx</span><span class="o">,</span> <span class="n">ball1</span><span class="o">.</span><span class="na">p0</span><span class="o">.</span><span class="na">y</span><span class="o">+</span><span class="n">vp</span><span class="o">.</span><span class="na">vy</span><span class="o">);</span>
<span class="n">vn</span><span class="o">.</span><span class="na">p1</span> <span class="o">=</span> <span class="n">ball2</span><span class="o">.</span><span class="na">p0</span><span class="o">;</span></code></pre></figure>

<p>우리는 이제 두 공의 크기를 더한 것에 대해 vn의 길이를 검사합니다. 만약 vn이 반경을 더한 것보다 길면 충돌이 없습니다. 
만약 vn의 길이가 그 것과 같으면 공1이 정확히 점 p2에 있을 때 충돌이 납니다. 
vn이 짧다면, 공1이 p2를 도달하기 전에 충돌이 일어납니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">  
<span class="kt">float</span> <span class="n">sumRadius</span> <span class="o">=</span> <span class="n">ball1</span><span class="o">.</span><span class="na">r</span> <span class="o">+</span> <span class="n">ball2</span><span class="o">.</span><span class="na">r</span><span class="o">;</span>
<span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">sumRadius</span> <span class="o">-</span> <span class="n">vn</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
<span class="k">if</span><span class="o">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
  <span class="c1">//collision</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
  <span class="c1">//no collision</span>
<span class="o">}</span></code></pre></figure>

<p>공 사이의 충돌을 한번 검출하면 공1을 점 p2에서 점 p3로 되돌려 놓아야 합니다. 그런데 p3는 어떻게 찾을까요? 위 그림에서 충돌하고 있는 공을 다시 살펴보면 여러분은 공2의 중심, p2, p3가 만드는 삼각형을 볼 수 있을 것입니다. 아마도 그 삼각형을 좋아할 정도는 아니지만, p3를 찾기 충분할 정도로 우리는 이미 이 삼각형에 대해 충분히 많이 알고 있습니다. 먼저, p2에서 공2의 중심까지 빗변 길이를 압니다. 이것은 벡터 vn이고 vn의 길이는 그 빗변의 길이입니다. 다음으로 우리는 또한 p3에서 공2의 중심까지 측면 길이를 압니다. 이것은 sumRadius와 같습니다. 이제 우리는 p2에서 p3까지 세번째 측면 길이를 구하기 위해 유용한 피타고라스 원리를 이용할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">  
<span class="kt">float</span> <span class="n">moveBack</span> <span class="o">=</span> <span class="n">sqrt</span><span class="o">(</span><span class="n">sumRadius</span><span class="o">*</span><span class="n">sumRadius</span> <span class="o">-</span> <span class="n">vn</span><span class="o">.</span><span class="na">length</span><span class="o">*</span><span class="n">vn</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="n">Point</span> <span class="n">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="o">();</span>
<span class="n">p3</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">vn</span><span class="o">.</span><span class="na">p0</span><span class="o">.</span><span class="na">x</span> <span class="o">-</span> <span class="n">moveBack</span><span class="o">*</span><span class="n">ball1</span><span class="o">.</span><span class="na">dx</span><span class="o">;</span>
<span class="n">p3</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">vn</span><span class="o">.</span><span class="na">p0</span><span class="o">.</span><span class="na">y</span> <span class="o">-</span> <span class="n">moveBack</span><span class="o">*</span><span class="n">ball1</span><span class="o">.</span><span class="na">dy</span><span class="o">;</span>
<span class="n">v3</span><span class="o">.</span><span class="na">p0</span> <span class="o">=</span> <span class="n">ball1</span><span class="o">.</span><span class="na">p0</span><span class="o">;</span>
<span class="n">v3</span><span class="o">.</span><span class="na">p1</span> <span class="o">=</span> <span class="n">p3</span><span class="o">;</span></code></pre></figure>

<p>그래서 moveBack 의 값만큼 p2에서 운동벡터 v의 반대방향으로 이동합니다. p3가 벡터 v의 밖에 있는 것은 이번 운동 사이클 동안 충돌이 일어나지 않을 것이며, 과거에 일어났거나 미래에 일어날 것임을 의미합니다. 우리는 지금 충돌에 대해서만 다룰 것이기에 벡터 v 위에 p3가 있는 것에 대해 검사해야 합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">  
<span class="k">if</span><span class="o">(</span><span class="n">v3</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="n">ball1</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">dotP</span><span class="o">(</span><span class="n">v3</span><span class="o">,</span> <span class="n">ball1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">ball1a</span><span class="o">.</span><span class="na">p0</span> <span class="o">=</span> <span class="n">p3</span><span class="o">;</span>
<span class="o">}</span> </code></pre></figure>

<p>먼저, 공1의 중심에서 p3 까지 벡터의 길이는 벡터 v의 길이보다 짧아야 합니다. 또한 두 벡터는 같은 방향일 필요가 있고, 이것은 두 벡터의 내적을 계산함으로써 구할 수 있습니다.</p>

<p>이 방법은 운동이 시작될 때 공들이 충돌하지 않고 있다고 가정하는 데, 이러한 상황은 이 단계에 대한 충돌을 계산하기 전에 잘 처리해야 합니다.</p>

<p>다른 공과 충돌하는 운동벡터를 가진 공 예제를 하나 만들었습니다.</p>

<canvas data-processing-sources="../data/ball_vs_moving_ball.pde"></canvas>
<p><small>(소스파일 <a href="../data/ball_vs_moving_ball.pde">pde</a>를 다운받을 수 있습니다.)</small></p>

<p>공 또는 벡터의 끝점을 드래그할 수 있습니다. 빨간 원은 공1의 시작점에 있고, 초록은 공1이 끝나는 곳이고, 파랑은 공2 입니다.</p>

<p><br />
<br />
다음 : <a href="/2DVectors/moving_balls/">Moving balls</a></p>


  </article>

  <!-- Your like button code -->
	<div class="fb-like" 
		data-href="http://localhost:4000/2DVectors/ball_vs_moving_ball/" 
		data-layout="button_count"
		data-action="like" 
		data-share="true"
		data-width="300"
		data-show-faces="false">
	</div>

</div>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">2D 벡터 알고리즘 기초</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li><a href="mailto:hansune@me.com">hansune@me.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/brownsoo">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">brownsoo</span>
            </a>
          </li>
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Basic 2D Vectors Algorithm 기초적인 2D 운동 벡터에 대해 배울 수 있습니다. 벡터를 이해하면, 움직임을 만드는 데 큰 도움이 됩니다.</p>
      </div>
    </div>

  </div>

</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-38112441-1', 'auto');
  ga('send', 'pageview');

</script>

<script>
    // Prevent scrolling when touching the canvas
    document.body.addEventListener("touchstart", function (e) {
      if (e.target.tagName == 'canvas') {
        e.preventDefault();
      }
    }, false);
    document.body.addEventListener("touchend", function (e) {
      if (e.target.tagName == 'canvas') {
        e.preventDefault();
      }
    }, false);
    document.body.addEventListener("touchmove", function (e) {
      if (e.target.tagName == 'canvas') {
        e.preventDefault();
      }
    }, false);
</script>


  </body>

</html>
